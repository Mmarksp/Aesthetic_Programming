# mini_ex9
*Mark Staun Poulsen*

<img src="Flowchart.jpg" width="1000">

For the individual work with one of my own previous mini_ex assignments, I have chosen the most technically complex one: [mini_ex5](https://github.com/Mmarksp/Aesthetic_Programming_2018/tree/master/mini_exercises/mini_ex5) (the one that never worked properly). Do open the picture in another tab to be able to zoom in.

I have not drawn this flowchart so as to be conceptually easy to grasp. Rather I have attempted to recreate a flowchart showing an in-depth representation of the workings of the algorithms within my program. Of course, this representation is not actually related to the mini_ex5 specifically. Rather, it is a representation of my own conceptual understanding of mini_ex5. This means that I, for instance, do not write more about a function such as createCanvas, because I simply do not know how that function works besides resulting in a created canvas. My understanding is quite limited, especially when it comes to the actual workings of a computer, but in my flowchart there is still a logic at play in the transitions from one function to another function, and in the dependencies of other functions having executed before a function is run. I think I have attempted to capture this rather extensively.

I suppose this also speaks to the difficulties of drawing flowcharts. In the end, they are not actually representative of the workings of a program - not fully. Instead, the author must assess the function of the flowchart, whom it is intended for, and from there decide how conceptually abstract the chart must be. I think it is safe to say that many of my functions are able to be written much more simpler and in more abstract terms. The avat.turn function can be written as something simpler: run function, check if A or D is currently pressed, return either -3, 0 or 3 depending on key pressed or key released. However, there is a danger in abstraction. While it can be great for communication, abstraction can eventually go too far out and lose key aspects of understanding the program properly. Where this is, how far it is out and how it varies depending on the persons seeing it, are very good questions to ponder.


## Group Work
Together with my group consisting of Martin, Magnus and Frederik, we came up with a lot of possible angles for our final project after a productive brainstorm. Nevertheless, we are required to form two concrete ideas (more or less). Thus, I will present our two ideas here, but at the same time also point out that our final project may become entirely different from these formulations.

<img src="Flowchart of PacMan.jpg" width="800">

Our first idea is a video game! It has no title yet, but since we thought of it as an alteration of the classic Pac Man, we may as well just call it that: PacMan. For now.
Anyway, in this game the setup of PacMan as we know it will be the same in our version. The player controls a main avatar. This avatar is supposed to navigate 2D-layout of a maze as seen from above, and in this maze the avatar is constantly hunted by other character's controlled by the algorithms of the program (basically AI's in video game terms). These characters, Ghosts, hunt down the player with high speed, and they are focused on reaching the player at all times. The player must not get caught, obviously. However, to do this the player not only uses the arrow keys in order to move, but also uses a slightly different means of control not found in the original game. Now, within the group we have not yet decided, how this implementation will impact the game, but we want to use a "light dependent resistor" (as Frederik calls it), and through it we are going to data capture light, and use this data to control aspects of the gameplay. In practical terms, this means that the player can let light shine upon the resistor, or obscure it by using his or her hand (or a towel), and through that impact the game somehow.

So far we have discussed two versions of gameplay. 1) by obscuring the resistor, the ghosts stop and the player does not have to worry about the ghosts catching him or her. At the same time, the screen turns completely dark (if obscured completely), which forces the player to sometimes remove his or her hand in order to let light in and see the layout of the maze in order to properly navigate. This inclusion of light then lets the ghosts move around again, shit. Now you may ask, why does the player need to move if the ghosts stand still when there is no light? Can the player not just do nothing and leave it at that? No, silly. The player must constantly seek out so called "light packages" in order to combat a constantly decreasing timer. These packages are randomly located somewhere in the maze, and upon acquisition another package will spawn somewhere else. This is a continuous cycle. Acquiring a package means acquiring a number, which is supplemented to the timer. If the timer turns to zero the player will lose.
2) The second version I am not too familiar with (can't remember it in detail). I will recommend looking through the README's of the rest of my group and see if they have written about this version. However, it is important to note that we have Not decided upon anything yet.

<img src="Flowchart of Chicago Police.jpg" width="500">

Our second idea is a critical look at data privacy. We were astonished to find an API offering arrest data from the Chicago Police Department to the public. This included mugshot photos. We want to take that data, which includes body physique of arrested people, arrest dates and so forth, and implement it in a fake facebook profile layout. The mugshot will be used as the profile picture, and then you can find something such as the arrest date in the same locations as "member since 2008" or something. This idea will then necessitate using an API extensively, and we will then also need to implement a facebook styling - probably through CSS. Finally, the user can then use the search bar to search for some sort of undefined insert element (an index number perhaps), and find other "profiles" of arrested people.


## Technical Difficulties
There are actual numerous concerns related to the actualisation of these two ideas. Most of them are actually concerns that can determine, whether or not we can complete any of these ideas in the first place.

1) For our PacMan game it is an obvious concern if "stealing" the code from an already established game, is somehow wrong in relation to this exam. While we definitely wish to expand upon the game structure it is a noteworthy concern that implementing a fixed template may be looked down upon. Furthermore, if we are allowed to do this, it is also not certain that we can even find a JavaScript version of Pac Man, which would mean that we would have to replicate the design of Pac Man by hand. This can be especially complicated with the creation of the AI-behaviour. Nevertheless, possible solutions for realising this idea is to consider using p5.play. There are many relevant "operational logics" of gaming, which are relevant in our case such as collision and use of objects (sprites in this case).
Furthermore, we also have to realise the use of a light dependent resistor. Frederik has experience using it, but all of us still have to completely understand the use of node.js and the resistor itself. Furthermore, we need to connect it to the workings of p5 and p5.play. We can easily imagine that these won't work together somehow.

Overall, it is easy to forget the middle-steps and just look at the final result, and in this case it becomes very important to iteratively evaluate how we are doing in our project

2) If we choose our second project, we would also face some issues. Firstly, we have to get the API to work. This requires a key, but it also requires that the API works and that we can establish querries interacting with the API. This is really not certain and so far we have not looked into it. Furthermore, it is also worth highlighting that we also have to figure our if all of this is completely legal. We suppose it is. It just seems very sketchy - to be able to just retrieve this sort of data - but at the same time this is also what we want to comment on and criticise. Lastly, we also need to find proper facebook styling, which we can use in CSS. Frederik has done some of this before, but he also says that it is a little difficult to actually find the CSS-styling.


## Personal Reflection
It is interesting to compare these two flowcharts with my original flowchart. In these two, we have specifically chosen to embrace a proper communication of what is still just a bunch of ideas, and this is best done by speaking of the algorithmic structure in terms of abstract metaphors and concepts. You can judge for yourself, but I find these two flowcharts easier to understand than my original one even though these last two are not as detailed. For my personal flowchart, I have specifically sought to produce a conceptual representation of the workings of my mini_ex5. This representation is not actually a representation of the program. Rather, it is a representation of how I understand its workings. This means that if I was to produce the most truthful translation of the code in a flowchart, I would have to dig much deeper. My personal flowchart is then something different than a truthful representation, but it is still very detailed and it contains all of the lines of JS-code in the program.

I think flowcharts represent algorithms rather well. Flowcharts are deterministic meaning that the current state of the program is necessary for the next state to be executed. Computers also go through algorithms deterministically. Fundamentally, algorithms encompass everything we work with using software and code. An algorithm always leads to some sort of result. Not only that, but there is an almost ideological tendency to then accept this result, this "magic of the algorithms", blindly. Who actually knows how an algorithm works? The horror of the the answer to this only becomes worse, when you start thinking about how extensively algorithms are used in our world today.

Because of this, it becomes essential to look critically at algorithms and understand two (that I can just think of from the top of my head) aspects in depth. 1) It is essential to realise that algorithms are constructed by people. There is, as said, a tendency to just believe this magic of the algorithm. Well, this magic does not just spring out of nowhere. It comes because someone has first of all defined the algorithm. This leaves open the implementation of all sorts of ideologies and values in the workings of the algorithm. These assumptions, ideas, values, politics and so forth are then brought into a system, where there mere presence causes an effect. Algorithms are statements made executable, as Goffey would probably say. In relation the effects of algorithms, Ed Finn writes: "The compromises and analogies of algorithmic approximations tend to efface everything that they do not comprehend". Therefore, we must understand the extent of these values, be they racism, sexism, liberalism, conservatism and so on and so on. The consequences of not doing this can be very severe. As long as algorithms are only understood as this trustworthy magic, their working will continue to stay "factual" in the minds of people.

2) Algorithms are also not at all perfect in their ability to produce a result. Perhaps the problem here simply lies in how we choose to interpret results from algorithms, but in continuing the sentiment of Ed Finn (that algorithms tend to leave out what it does not comprehend) I think it is also essential to look at the results and ponder, how the algorithm came to this conclusion. If the algorithm is using statistical tools in order to, say, put people on a terrorist watch list (here's looking at you US), then we must really consider how right the results are. If the likelihood of putting the right people on the list is 99.9, then the 0.1 percent error is still far too much considering the enormous amount of people this algorithm will sift through.
